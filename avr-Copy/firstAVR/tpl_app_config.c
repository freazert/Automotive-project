/**
 * @file tpl_app_config.c
 *
 * @section desc File description
 *
 * OS data structure generated from application test
 * Automatically generated by goil on Thu Jun 21 03:37:10 2018
 * from root OIL file firstAVR.oil
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

#include "tpl_app_config.h"

#include "tpl_os_internal_types.h"
#include "tpl_machine.h"
#include "tpl_os_it.h"
#include "tpl_os_it_kernel.h"
#include "tpl_os_alarm_kernel.h"
#include "tpl_os_alarm.h"
#include "tpl_os_rez_kernel.h"
#include "tpl_os_rez.h"
#include "tpl_os_event_kernel.h"
#include "tpl_os_event.h"
#include "tpl_os_action.h"
#include "tpl_os_kernel.h"
#include "tpl_os_definitions.h"


#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

/*=============================================================================
 * Declaration of processes IDs
 */

/* Task periodicTask identifier */
#define periodicTask_id 0
CONST(TaskType, AUTOMATIC) periodicTask = periodicTask_id;

/* Task secondTask identifier */
#define secondTask_id 1
CONST(TaskType, AUTOMATIC) secondTask = secondTask_id;

/* Task startTask identifier */
#define startTask_id 2
CONST(TaskType, AUTOMATIC) startTask = startTask_id;

/* Task stopCANTask identifier */
#define stopCANTask_id 3
CONST(TaskType, AUTOMATIC) stopCANTask = stopCANTask_id;

/* ISR adcISR1 identifier */
#define adcISR1_id 4
/* ISR boutonISR1 identifier */
#define boutonISR1_id 5
/* ISR boutonISR4 identifier */
#define boutonISR4_id 6
/* ISR boutonISR5 identifier */
#define boutonISR5_id 7
/* ISR boutonISR6 identifier */
#define boutonISR6_id 8
/* ISR boutonISR7 identifier */
#define boutonISR7_id 9
/*=============================================================================
 * Declaration of Alarm IDs
 */

/* Alarm periodicAl identifier */
#define periodicAl_id 0
CONST(AlarmType, AUTOMATIC) periodicAl = periodicAl_id;

#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_resource, AUTOMATIC, OS_APPL_DATA)
tpl_resource_table[RESOURCE_COUNT] = {
  &res_sched_rez_desc  
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of Counters related defines and structures
 */
/*-----------------------------------------------------------------------------
 * Counter SystemCounter descriptor
 */

#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_tick, OS_CONST) OSTICKSPERBASE = 10;
CONST(tpl_tick, OS_CONST) OSMAXALLOWEDVALUE = 1000;
CONST(tpl_tick, OS_CONST) OSMINCYCLE = 1;

#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_counter, OS_VAR) SystemCounter_counter_desc = {
  /* ticks per base       */  10,
  /* max allowed value    */  1000,
  /* minimum cycle        */  1,
  /* current tick         */  0,
  /* current date         */  0,
#if WITH_OSAPPLICATION == YES
    /* OS Application id    */  
#endif
    /* first alarm          */  NULL_PTR,
    /* next alarm to raise  */  NULL_PTR
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#include "tpl_os_kernel.h"          /* tpl_schedule */
#include "tpl_os_timeobj_kernel.h"  /* tpl_counter_tick */
#include "tpl_machine_interface.h"  /* tpl_switch_context_from_it */

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

//gcc uses ISR as a keyword to define an interrupt handler.
//Osek uses ISR to define an ISR2 :-/
#ifdef ISR
 #undef ISR
#endif
#include <avr/interrupt.h>


ISR(TIMER2_OVF_vect)
{
  tpl_status  need_rescheduling = NO_SPECIAL_CODE;


  need_rescheduling |= tpl_counter_tick(&SystemCounter_counter_desc);

  if (need_rescheduling == NEED_RESCHEDULING)
  {
    tpl_schedule_from_running();
#if WITH_SYSTEM_CALL == NO
    if (tpl_kern.need_switch != NO_NEED_SWITCH) {
      tpl_switch_context_from_it(
        &(tpl_kern.s_old->context),
        &(tpl_kern.s_running->context)
      );
    }
#endif
  }
}


#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"

/*=============================================================================
 * Definition and initialization of Task related defines and structures
 */
/*-----------------------------------------------------------------------------
 * Task periodicTask descriptor
 */
#define APP_Task_periodicTask_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task periodicTask function prototype
 */
FUNC(void, OS_APPL_CODE) periodicTask_function(void);
#define APP_Task_periodicTask_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * Task periodicTask stack
 *
 */
#define APP_Task_periodicTask_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word periodicTask_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_Task_periodicTask_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define periodicTask_STACK { periodicTask_stack_zone, 256 }

/*
 * Task periodicTask context
 */
avr_context periodicTask_int_context;

#define periodicTask_CONTEXT { &periodicTask_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task periodicTask
 */
CONST(tpl_proc_static, OS_CONST) periodicTask_task_stat_desc = {
  /* context                  */  periodicTask_CONTEXT,
  /* stack                    */  periodicTask_STACK,
  /* entry point (function)   */  periodicTask_function,
  /* internal ressource       */  NULL,
  /* task id                  */  periodicTask_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  3,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task periodicTask
 */
VAR(tpl_proc, OS_VAR) periodicTask_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  3,
  /* task state                     */  SUSPENDED
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
    /* activation allowed             */  ,TRUE
#endif
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task secondTask descriptor
 */
#define APP_Task_secondTask_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task secondTask function prototype
 */
FUNC(void, OS_APPL_CODE) secondTask_function(void);
#define APP_Task_secondTask_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * Task secondTask stack
 *
 */
#define APP_Task_secondTask_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word secondTask_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_Task_secondTask_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define secondTask_STACK { secondTask_stack_zone, 256 }

/*
 * Task secondTask context
 */
avr_context secondTask_int_context;

#define secondTask_CONTEXT { &secondTask_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task secondTask
 */
CONST(tpl_proc_static, OS_CONST) secondTask_task_stat_desc = {
  /* context                  */  secondTask_CONTEXT,
  /* stack                    */  secondTask_STACK,
  /* entry point (function)   */  secondTask_function,
  /* internal ressource       */  NULL,
  /* task id                  */  secondTask_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task secondTask
 */
VAR(tpl_proc, OS_VAR) secondTask_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  SUSPENDED
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
    /* activation allowed             */  ,TRUE
#endif
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task startTask descriptor
 */
#define APP_Task_startTask_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task startTask function prototype
 */
FUNC(void, OS_APPL_CODE) startTask_function(void);
#define APP_Task_startTask_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * Task startTask stack
 *
 */
#define APP_Task_startTask_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word startTask_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_Task_startTask_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define startTask_STACK { startTask_stack_zone, 256 }

/*
 * Task startTask context
 */
avr_context startTask_int_context;

#define startTask_CONTEXT { &startTask_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task startTask
 */
CONST(tpl_proc_static, OS_CONST) startTask_task_stat_desc = {
  /* context                  */  startTask_CONTEXT,
  /* stack                    */  startTask_STACK,
  /* entry point (function)   */  startTask_function,
  /* internal ressource       */  NULL,
  /* task id                  */  startTask_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  2,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task startTask
 */
VAR(tpl_proc, OS_VAR) startTask_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  2,
  /* task state                     */  AUTOSTART
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
    /* activation allowed             */  ,TRUE
#endif
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task stopCANTask descriptor
 */
#define APP_Task_stopCANTask_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task stopCANTask function prototype
 */
FUNC(void, OS_APPL_CODE) stopCANTask_function(void);
#define APP_Task_stopCANTask_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * Task stopCANTask stack
 *
 */
#define APP_Task_stopCANTask_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word stopCANTask_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_Task_stopCANTask_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define stopCANTask_STACK { stopCANTask_stack_zone, 256 }

/*
 * Task stopCANTask context
 */
avr_context stopCANTask_int_context;

#define stopCANTask_CONTEXT { &stopCANTask_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task stopCANTask
 */
CONST(tpl_proc_static, OS_CONST) stopCANTask_task_stat_desc = {
  /* context                  */  stopCANTask_CONTEXT,
  /* stack                    */  stopCANTask_STACK,
  /* entry point (function)   */  stopCANTask_function,
  /* internal ressource       */  NULL,
  /* task id                  */  stopCANTask_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  4,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task stopCANTask
 */
VAR(tpl_proc, OS_VAR) stopCANTask_task_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* task priority                  */  4,
  /* task state                     */  SUSPENDED
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
    /* activation allowed             */  ,TRUE
#endif
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of ISR2 related defines and structures
 */
/*-----------------------------------------------------------------------------
 * ISR adcISR1 descriptor
 */
#define APP_ISR_adcISR1_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR adcISR1 function prototype
 */
FUNC(void, OS_APPL_CODE) adcISR1_function(void);
#define APP_ISR_adcISR1_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * ISR adcISR1 stack
 *
 */
#define APP_ISR_adcISR1_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word adcISR1_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_ISR_adcISR1_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define adcISR1_STACK { adcISR1_stack_zone, 256 }

/*
 * ISR adcISR1 context
 */
avr_context adcISR1_int_context;

#define adcISR1_CONTEXT { &adcISR1_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

#include <avr/interrupt.h>
ISR (ADC_vect)
{
  tpl_central_interrupt_handler(adcISR1_id);
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR adcISR1
 */
CONST(tpl_proc_static, OS_CONST) adcISR1_isr_stat_desc = {
  /* context                  */  adcISR1_CONTEXT,
  /* stack                    */  adcISR1_STACK,
  /* entry point (function)   */  adcISR1_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  adcISR1_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  5,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

tpl_isr_static adcISR1_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     adcISR1_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR adcISR1
 */
VAR(tpl_proc, OS_VAR) adcISR1_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  5,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * ISR boutonISR1 descriptor
 */
#define APP_ISR_boutonISR1_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR boutonISR1 function prototype
 */
FUNC(void, OS_APPL_CODE) boutonISR1_function(void);
#define APP_ISR_boutonISR1_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * ISR boutonISR1 stack
 *
 */
#define APP_ISR_boutonISR1_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word boutonISR1_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_ISR_boutonISR1_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define boutonISR1_STACK { boutonISR1_stack_zone, 256 }

/*
 * ISR boutonISR1 context
 */
avr_context boutonISR1_int_context;

#define boutonISR1_CONTEXT { &boutonISR1_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

#include <avr/interrupt.h>
ISR (INT1_vect)
{
  tpl_central_interrupt_handler(boutonISR1_id);
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR boutonISR1
 */
CONST(tpl_proc_static, OS_CONST) boutonISR1_isr_stat_desc = {
  /* context                  */  boutonISR1_CONTEXT,
  /* stack                    */  boutonISR1_STACK,
  /* entry point (function)   */  boutonISR1_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  boutonISR1_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  5,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

tpl_isr_static boutonISR1_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     boutonISR1_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR boutonISR1
 */
VAR(tpl_proc, OS_VAR) boutonISR1_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  5,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * ISR boutonISR4 descriptor
 */
#define APP_ISR_boutonISR4_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR boutonISR4 function prototype
 */
FUNC(void, OS_APPL_CODE) boutonISR4_function(void);
#define APP_ISR_boutonISR4_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * ISR boutonISR4 stack
 *
 */
#define APP_ISR_boutonISR4_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word boutonISR4_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_ISR_boutonISR4_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define boutonISR4_STACK { boutonISR4_stack_zone, 256 }

/*
 * ISR boutonISR4 context
 */
avr_context boutonISR4_int_context;

#define boutonISR4_CONTEXT { &boutonISR4_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

#include <avr/interrupt.h>
ISR (INT4_vect)
{
  tpl_central_interrupt_handler(boutonISR4_id);
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR boutonISR4
 */
CONST(tpl_proc_static, OS_CONST) boutonISR4_isr_stat_desc = {
  /* context                  */  boutonISR4_CONTEXT,
  /* stack                    */  boutonISR4_STACK,
  /* entry point (function)   */  boutonISR4_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  boutonISR4_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  5,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

tpl_isr_static boutonISR4_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     boutonISR4_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR boutonISR4
 */
VAR(tpl_proc, OS_VAR) boutonISR4_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  5,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * ISR boutonISR5 descriptor
 */
#define APP_ISR_boutonISR5_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR boutonISR5 function prototype
 */
FUNC(void, OS_APPL_CODE) boutonISR5_function(void);
#define APP_ISR_boutonISR5_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * ISR boutonISR5 stack
 *
 */
#define APP_ISR_boutonISR5_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word boutonISR5_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_ISR_boutonISR5_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define boutonISR5_STACK { boutonISR5_stack_zone, 256 }

/*
 * ISR boutonISR5 context
 */
avr_context boutonISR5_int_context;

#define boutonISR5_CONTEXT { &boutonISR5_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

#include <avr/interrupt.h>
ISR (INT5_vect)
{
  tpl_central_interrupt_handler(boutonISR5_id);
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR boutonISR5
 */
CONST(tpl_proc_static, OS_CONST) boutonISR5_isr_stat_desc = {
  /* context                  */  boutonISR5_CONTEXT,
  /* stack                    */  boutonISR5_STACK,
  /* entry point (function)   */  boutonISR5_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  boutonISR5_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  5,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

tpl_isr_static boutonISR5_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     boutonISR5_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR boutonISR5
 */
VAR(tpl_proc, OS_VAR) boutonISR5_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  5,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * ISR boutonISR6 descriptor
 */
#define APP_ISR_boutonISR6_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR boutonISR6 function prototype
 */
FUNC(void, OS_APPL_CODE) boutonISR6_function(void);
#define APP_ISR_boutonISR6_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * ISR boutonISR6 stack
 *
 */
#define APP_ISR_boutonISR6_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word boutonISR6_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_ISR_boutonISR6_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define boutonISR6_STACK { boutonISR6_stack_zone, 256 }

/*
 * ISR boutonISR6 context
 */
avr_context boutonISR6_int_context;

#define boutonISR6_CONTEXT { &boutonISR6_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

#include <avr/interrupt.h>
ISR (INT6_vect)
{
  tpl_central_interrupt_handler(boutonISR6_id);
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR boutonISR6
 */
CONST(tpl_proc_static, OS_CONST) boutonISR6_isr_stat_desc = {
  /* context                  */  boutonISR6_CONTEXT,
  /* stack                    */  boutonISR6_STACK,
  /* entry point (function)   */  boutonISR6_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  boutonISR6_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  5,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

tpl_isr_static boutonISR6_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     boutonISR6_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR boutonISR6
 */
VAR(tpl_proc, OS_VAR) boutonISR6_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  5,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * ISR boutonISR7 descriptor
 */
#define APP_ISR_boutonISR7_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR boutonISR7 function prototype
 */
FUNC(void, OS_APPL_CODE) boutonISR7_function(void);
#define APP_ISR_boutonISR7_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */

/*
 * ISR boutonISR7 stack
 *
 */
#define APP_ISR_boutonISR7_START_SEC_STACK
#include "tpl_memmap.h"
tpl_stack_word boutonISR7_stack_zone[256/sizeof(tpl_stack_word)];
#define APP_ISR_boutonISR7_STOP_SEC_STACK
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define boutonISR7_STACK { boutonISR7_stack_zone, 256 }

/*
 * ISR boutonISR7 context
 */
avr_context boutonISR7_int_context;

#define boutonISR7_CONTEXT { &boutonISR7_int_context }

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

#include <avr/interrupt.h>
ISR (INT7_vect)
{
  tpl_central_interrupt_handler(boutonISR7_id);
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR boutonISR7
 */
CONST(tpl_proc_static, OS_CONST) boutonISR7_isr_stat_desc = {
  /* context                  */  boutonISR7_CONTEXT,
  /* stack                    */  boutonISR7_STACK,
  /* entry point (function)   */  boutonISR7_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  boutonISR7_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  5,
  /* max activation count     */  1,
  /* task type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

tpl_isr_static boutonISR7_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     boutonISR7_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR boutonISR7
 */
VAR(tpl_proc, OS_VAR) boutonISR7_isr_desc = {
  /* resources                      */  NULL,
#if WITH_MEMORY_PROTECTION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_MEMORY_PROTECTION */
  /* activate count                 */  0,
  /* ISR priority                   */  5,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
/*=============================================================================
 * Definition and initialization of process tables (tasks and isrs)
 */
CONSTP2CONST(tpl_proc_static, AUTOMATIC, OS_APPL_DATA)
tpl_stat_proc_table[TASK_COUNT+ISR_COUNT+1] = {
  &periodicTask_task_stat_desc,
  &secondTask_task_stat_desc,
  &startTask_task_stat_desc,
  &stopCANTask_task_stat_desc,
  &adcISR1_isr_stat_desc,
  &boutonISR1_isr_stat_desc,
  &boutonISR4_isr_stat_desc,
  &boutonISR5_isr_stat_desc,
  &boutonISR6_isr_stat_desc,
  &boutonISR7_isr_stat_desc,
  &idle_task_static
};

CONSTP2VAR(tpl_proc, AUTOMATIC, OS_APPL_DATA)
tpl_dyn_proc_table[TASK_COUNT+ISR_COUNT+1] = {
  &periodicTask_task_desc,
  &secondTask_task_desc,
  &startTask_task_desc,
  &stopCANTask_task_desc,
  &adcISR1_isr_desc,
  &boutonISR1_isr_desc,
  &boutonISR4_isr_desc,
  &boutonISR5_isr_desc,
  &boutonISR6_isr_desc,
  &boutonISR7_isr_desc,
  &idle_task
};

CONSTP2CONST(tpl_isr_static, AUTOMATIC, OS_APPL_DATA)
tpl_isr_stat_table[ISR_COUNT] = {
  &adcISR1_isr_helper,
  &boutonISR1_isr_helper,
  &boutonISR4_isr_helper,
  &boutonISR5_isr_helper,
  &boutonISR6_isr_helper,
  &boutonISR7_isr_helper
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of Alarm related structures
 */
/*-----------------------------------------------------------------------------
 * Alarm periodicAl descriptor
 *
 * This alarm does the activation of task periodicTask
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


CONST(tpl_task_activation_action, OS_CONST) periodicAl_action = {
  {
    /* action function  */  tpl_action_activate_task
  },
  /* task id            */  periodicTask_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

 
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_alarm_static, OS_CONST) periodicAl_static = {
  {
    /* pointer to counter           */  &SystemCounter_counter_desc,
    /* pointer to the expiration    */  tpl_raise_alarm
#if (WITH_TRACE == YES)
    /* id of the alarm for tracing  */  , periodicAl_id
#endif
#if WITH_OSAPPLICATION == YES
    /* OS application id            */  , 
#endif
  },
  /* action of the alarm  */  (tpl_action *)&periodicAl_action
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_time_obj, OS_VAR) periodicAl_alarm_desc = {
    /* pointer to the static part   */  (tpl_time_obj_static *)&periodicAl_static,
    /* next alarm                   */  NULL,
    /* prev alarm                   */  NULL,
    /* cycle                        */  1,
    /* date                         */  1,
    /* State of the alarm           */  ALARM_AUTOSTART
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_time_obj, AUTOMATIC, OS_APPL_DATA)
  tpl_alarm_table[ALARM_COUNT] = {
  &periodicAl_alarm_desc
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

/*=============================================================================
 * Declaration of flags functions
 */
/* $FLAGSFUNCTIONS$ */


/*=============================================================================
 * Definition and initialization of Ready List structures
 */
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_proc_id, OS_VAR) tpl_priority_0_fifo[1];
VAR(tpl_proc_id, OS_VAR) tpl_priority_1_fifo[1];
VAR(tpl_proc_id, OS_VAR) tpl_priority_2_fifo[1];
VAR(tpl_proc_id, OS_VAR) tpl_priority_3_fifo[1];
VAR(tpl_proc_id, OS_VAR) tpl_priority_4_fifo[2];
VAR(tpl_proc_id, OS_VAR) tpl_priority_5_fifo[6];

VAR(tpl_fifo_state, OS_VAR) tpl_fifo_rw[6] = {
  { 0 , 0 },
  { 0 , 0 },
  { 0 , 0 },
  { 0 , 0 },
  { 0 , 0 },
  { 0 , 0 }
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_priority_level, OS_CONST) tpl_ready_list[6] = {
  { tpl_priority_0_fifo, 1 },
  { tpl_priority_1_fifo, 1 },
  { tpl_priority_2_fifo, 1 },
  { tpl_priority_3_fifo, 1 },
  { tpl_priority_4_fifo, 2 },
  { tpl_priority_5_fifo, 6 }
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2CONST(char, AUTOMATIC, OS_APPL_DATA) proc_name_table[TASK_COUNT + ISR_COUNT] = {
  "periodicTask",
  "secondTask",
  "startTask",
  "stopCANTask",
  "adcISR1",
  "boutonISR1",
  "boutonISR4",
  "boutonISR5",
  "boutonISR6",
  "boutonISR7"
};
#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

/* End of file tpl_app_config.c */

